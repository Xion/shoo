#!/bin/sh

# shoo -- `kill` on steroids
# by Karol Kuczmarski "Xion"
# License: BSD

# Example usage:
#   $ shoo 642  # get rid of process with given PID
#   $ shoo --pid 642  # full form of the command above
#   $ shoo chrome  # get rid of processes with given name
#   $ shoo --name chrome  # full form of the command above
#   $ shoo --from ./foo.txt  # get rid of processes hogging the ./foo.txt file
#   $ shoo --from  file:./foo.txt  # full form of the command above
#   $ shoo --from tcp:8080  # get rid of processes listening on TCP port 8080
#   $ shoo --pid 642 --with int  # specify what signal to send to the process


SIGNALS="int term kill 2 15 9"

# Variables storing command line input data
pname=""
pid=0
from=""
with=""

# Other data
kill_flags=""


main() {
    parse_cmdline "$@"
    validate_input

    # format the signal flag to kill/killall
    if [[ -n "$with" ]]; then
        kill_flags="-$with"
    else
        kill_flags="-9"  # NO REMORSE
    fi

    if [[ -z "$from" ]]; then
        kill_specific_process
    else
        release_resource
    fi
}


# Command line handling

usage() {
    logf "usage: shoo [[--pid|--name] process] [--from resource] [--with signal]\n"
}

parse_cmdline() {
    # handle command line flags first (both short and long form)
    # (based on http://mywiki.wooledge.org/BashFAQ/035)
    while :
    do
        case $1 in
            --help | -h | -\?)
                usage
                exit 0
                ;;

            --pid | -p)     pid=$2; shift 2 ;;
            --pid=*)        pid=${1#*=}; shift ;;

            --name | -n)    pname=$2; shift 2 ;;
            --name=*)       pname=${1#*=}; shift ;;

            --from | -f)    from=$2; shift 2 ;;
            --from=*)       from=${1#*=}; shift ;;

            --with | -w)    with=$2; shift 2 ;;
            --with=*)       with=${1#*=}; shift ;;

            --) shift; break;;  # end of options
            -*) warnf 'Unknown option: %s (ignored)\n' "$1"; shift;;
            *)  break;;  # non-option, also end
        esac
    done

    # remaining command line arguments, if any,
    # are interpreted as either process name or PID
    if [[ -n "$1" ]]; then
        local desc="$1"
        if is_int "$desc"; then
            if [[ "$pid" -eq 0 ]]; then
                pid="$desc"
            else
                errf 'Duplicate value for PID: %s and %s' "$pid" "$desc"
                exit 1
            fi
        else
            if [[ -z "$pname" ]]; then
                pname="$desc"
            else
                errf 'Duplicate value for process name: "%s" and "%s"' \
                    "$pname" "$desc"
                exit 1
            fi
        fi

        shift
    fi

    # warn about any extraneous arguments, as they'll be ignored
    # TODO(xion): allow for positional arguments to be interleaved with flags
    if [[ -n "$1" ]]; then
        errf 'WARN: Ignoring extraneous arguments: %s' "$*"
    fi
}

validate_input() {
    # if nothing was supplied, display usage help and quit
    if [[ -z "$pname" ]] && [[ "$pid" -eq 0 ]] && [[ -z "$from" ]]; then
        usage
        exit 1
    fi

    # either a process name or PID can be supplied, but not both
    if [[ -n "$pname" ]] && [[ "$pid" -ne 0 ]]; then
        errf 'Specify either a process name or PID, not both'
        exit 1
    fi

    # if --with was specified, it better be a signal
    # that can actually end the target process
    if [[ -n "$with" ]]; then
        if ! contains "$SIGNALS" $(lowercase "$with"); then
            warnf 'Signal "%s" may not necessarily end the target process' \
                "$with"
        fi
    fi
}


# Process killing logic

kill_specific_process() {
    if [[ -n "$pname" ]]; then
        killall $kill_flags "$pname"
    else
        kill $kill_flags "$pid"
    fi
}

release_resource() {
    local type_ name
    split "$from" ':' type_ name

    # if resource type wasn't explicitly specified,
    # try to do some intelligent guessing
    if [[ "$type_" = "$from" ]]; then
        name="$type_"
        type_=$(is_int "$name" && echo 'tcp' || echo 'file')
        warnf "Resource type not specified, assuming '%s'" "$type_"
    fi

    # retireve PIDs of processes that squat given resource
    local procs
    case $(lowercase "$type_") in
        tcp | udp)
            procs=$(lsof -t -i "$type_:$name")
            ;;
        file)
            procs=$(lsof -t "$name")
            ;;
        *)
            errf "Unknown resource type: %s" "$type_"
            exit 1
            ;;
    esac

    # filter it through --name/--pid constraints, if any
    local filtered=true
    if [[ -n "$pname" ]]; then
        procs=$(intersection "$procs" $(pgrep "$pname"))
    elif [[ "$pid" -gt 0 ]]; then
        procs=$(intersection "$procs" "$pid")
    else
        filtered=false
    fi
    procs=$(trim "$procs")

    # shoo them!
    local proc_count="${#procs[@]}"
    if [[ "$proc_count" -eq 0 ]] || [[ -z "$procs" ]]; then
        # TODO(xion): figure out why the part after || is needed in `if` above
        if [[ $filtered = true ]]; then
            warnf "No processes matching given criteria"
        else
            warnf "No processes are currently using resource '%s'" "$from"
        fi
        exit 0
    else
        echo "$procs" | xargs kill $kill_flags
        if [[ "$proc_count" -gt 1 ]] || [[ $filtered = true ]]; then
            infof "%s processes shoo'd" "$proc_count"
        fi
    fi
}


# Utility functions

logf() {
    printf >&2 "$@"
}
errf() {
    local fmt="$1"; shift
    logf "ERROR: $fmt\n" "$@"
}
warnf() {
    local fmt="$1"; shift
    logf "WARN: $fmt\n" "$@"
}
infof() {
    local fmt="$1"; shift
    logf "INFO: $fmt\n" "$@"
}

is_int() {
    case $1 in
        ''|*[!0-9]*)    return 1;;  # not a number
        *)              return 0;;  # a number
    esac
}

contains() {
    local string="$1"
    local substring="$2"
    [ "${string#*$substring}" != "$string" ]
}

lowercase() {
    echo "$1" | tr '[:upper:]' '[:lower:]'
}

split() {
    # Split a string $1 by deliiter $2 into given variables
    local arg="$1"; shift
    local delim="$1"; shift
    IFS="$delim" read -r "$@" <<< "$arg"
}

trim() {
    echo "$1" | sed -e 's/^ *//' -e 's/ *$//'
}

intersection() {
    # Compute intersection of lists given as arguments
    echo "$@" | tr ' ' '\n' | sort | uniq -d
}


main "$@"
